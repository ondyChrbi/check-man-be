scalar DateTime
scalar JSON

type Query {
    courses: [Course!]!
    challenges(semesterId: ID!): [Challenge!]!
    requirements(challengeId: ID!): [Requirement!]!
    course(id: ID!): Course
    semester(id: ID!): Semester
    semesters(courseId: ID!, oderBy: SemesterOrderByField, sortOrder: SortOrder, pageSize: Int, page: Int): [Semester!]!
    statistic(semesterId: ID!, direction: Order, limit: Int, description: String): [FeedbackStatistics!]!
    challenge(id: ID!): Challenge
    testResult(id: ID!): TestResult
    me: AppUser!
    appUser(id: ID!): AppUser!
    myCourses: [Course!]!
    availableCourses: [Course!]!
    courseRoles(id: ID!): [String!]!
    allCourseRoles: [CourseSemesterRole!]!
    solutions(challengeId: ID!): [Solution!]!
    solution(id: ID!): Solution!
    countToReview(challengeId: ID!): Int!
    solutionsToReview(challengeId: ID!, offset: Int, size: Int): [Solution!]!
    allSolutionsToReview(courseId: ID!): [CoursesReviewList]
    semesterAccessRequests(semesterId: ID!): [CourseSemesterAccessRequest!]!
    semesterAccessRequestsAppUser(semesterId: ID!, appUserId: ID): CourseSemesterAccessRequest
}

type Mutation {
    createCourse(input: CourseInput!): Course!
    createSemester(courseId: ID!, input: SemesterInput!): Semester!
    createChallenge(semesterId: ID!, input: ChallengeInput!): Challenge!
    editChallenge(challengeId: ID!, input: ChallengeInput!): Challenge!
    deleteChallenge(challengeId: ID!): Challenge!
    createRequirement(challengeId: ID!, input: RequirementInput!): Requirement!
    editRequirement(requirementId: ID!, input: RequirementInput!): Requirement!
    removeRequirement(requirementId: ID!): Requirement!
    createSemesterAccessRequest(semesterId: ID!): CourseSemesterAccessRequest!
    editSemesterRequirements(semesterId: ID!, input: CourseSemesterRequirementsInput!): Semester!
    publishChallenge(challengeId: ID!): Boolean
    createFeedback(feedback: FeedbackInput!): Feedback!
    removeFeedbackFromReview(reviewId: ID!, feedbackId: ID!): Boolean
    addFeedbackToReview(reviewId: ID!, feedbackId: ID!): Boolean
    createFeedbackToReview(reviewId: ID!, feedback: FeedbackInput!): Feedback!
    createReview(solutionId: ID! reviewInput: ReviewInput!): Review!
    publishReview(id: ID!, status: String!): Boolean!
    editReview(id: ID!, input: ReviewInput!): Review!
    addCourseRole(appUserId: ID!, semesterId: ID!, roleId: ID!): Boolean
    removeCourseRole(appUserId: ID!, semesterId: ID!, roleId: ID!): Boolean
    editReviewPoints(reviewId: ID!, requirementId: ID!, reviewPointsInput: ReviewPointsInput!): Boolean
    approveCourseSemesterRequest(id: ID!, roles: [String!]): Boolean!
}

type AppUser{
    id: ID!
    stagId: String!
    mail: String!
    displayName: String!
    registrationDate: String!
    lastAccessDate: String!
    disabled: Boolean!
    globalRoles: [GlobalRole!]!
    courseRoles: [CourseSemesterRoles!]!
    roles(semesterId: ID!): [CourseSemesterRole!]!
    accessRequests: [CourseSemesterAccessRequest!]!
}

type GlobalRole {
    id: ID!
    name: String!
}

type CourseSemesterAccessRequest {
    semesterId: ID!,
    appUser: AppUser!,
    creationDate: String!,
    expirationDate: String!,
    id: String!
}

type Semester {
    id: ID!
    note: String
    dateStart: String!
    dateEnd: String!
    fulfillmentConditions: CourseSemesterRequirements
    statistic: [FeedbackStatistics!]
    relatedUsers(offset: Int, size: Int): [AppUser!]!
    page: Int
    pageSize: Int
}

type CourseSemesterRequirements {
    minOptional: Int!,
    minMandatory: Int!,
    minCredit: Int!,
    minExam: Int!,
}

type Challenge {
    id: ID!
    name: String!
    description: String!
    deadlineDate: String
    startDate: String
    author: AppUser
    published: Boolean,
    challengeKind: String!
    requirements: [Requirement!]!
}

type CourseSemesterRoles {
    semester: Semester!
    roles: [CourseSemesterRole!]!
}

type CourseSemesterRole {
    id: ID!
    name: String!
}

type Requirement {
    id: ID!,
    name: String!,
    description: String,
    active: Boolean!,
    minPoint: Int,
    maxPoint: Int
}

type ReviewedRequirement {
    id: ID!,
    points: Int
    description: String,
    requirement: Requirement,
}

type Course {
    id: ID
    stagId: String!
    name: String!
    dateCreation: String!
    icon: String
    template: String
    semesters(semesterSortBy: SemesterOrderByField): [Semester!]!
}

type ChallengeSolutions {
    challenge: Challenge,
    solutions: [Solution!]
}

type CoursesReviewList{
    course: Semester,
    reviews: [ChallengeSolutions!]!
}

type Solution {
    id: ID!
    uploadDate: DateTime!
    status: String!
    review: Review,
    author: AppUser,
    testResult: TestResult,
}

type Feedback {
    id: ID!,
    description: String!
    type: String!
}

type Review{
    id: ID!
    description: String!
    requirements: [ReviewedRequirement!]!
    feedbacks: [Feedback!]!
}

type TestResult {
    id: ID
    log: String
    creationDate: DateTime
    updateDate: DateTime
    status: TestStatus,
    feedbacks: [Feedback!]
}

type FeedbackStatistics {
    semesterId: ID
    challengeId: ID
    description: String
    feedbackTypeId: ID
    feedbackName: String
    count: Int
}

enum TestStatus {
    WAITING_TO_TEST,
    RUNNING,
    FINISHED,
    ERROR
}

enum Order {
    ASC,
    DESC,
}

input CourseInput {
    stagId: String!
    name: String!
    icon: String
    template: String
    semesters: [SemesterInput]
}

input ChallengeInput {
    name: String!
    description: String
    deadlineDate: String
    startDate: String
    challengeKind: String!
}

input ReviewInput {
    description: String!
}

input SemesterInput {
    note: String
    dateStart: DateTime
    dateEnd: DateTime
}

input RequirementInput {
    name: String!,
    description: String,
    minPoint: Int,
    maxPoint: Int
}

input FeedbackInput {
    description: String!
    type: String!
}

input ReviewPointsInput {
    points: Int!
}

input CourseSemesterRequirementsInput {
    minOptional: Int!,
    minMandatory: Int!,
    minCredit: Int!,
    minExam: Int!,
}

enum SemesterOrderByField {
    id,
    dateStart,
    dateEnd
}

enum SortOrder {
    ASC,
    DESC
}
